late days used: 2

1.

This was an interesting project and I really got to see how we can connect so many programs and use their methods and things to help us build what we need. This was a more straightforward project and the beginning was not too hard to figure out other than my endOfLine method where I did get a bit confused on looking at the adjacent vertices since Graph returns the adjacent vertices as an iterable and I wasn't sure how to go about checking them but I figured I had to go through the adjacent values in a for loop style. For Part 3 I think it was pretty easy to figure out what to do from the examples in our textbook I spent time mostly on formatting and making sure to show the name of the line and show it again only if there is a change of line. I got stuck on part 4 because I wasn't sure how to approach the problem and I knew I had to feed an EdgeWeightedDigraph to DijkstraSP but when I was thinking about filling the EdgeWeightedDigraph with new edges as I go through the vertices, I didn't realize that first before that can even happen I had to create a DirectedEdge object since thats what the addEdge function takes as an argument. So once I have the vertex and go through its adjacent vertices I can add the start, end, and weight of that edge to a DirectedEdge object and THEN add that to the new EdgeWeightedDigraph. The book is useful at explaining the algorithm and drawing things out so I can visualize what its doing. It was interesting to see us be able to not just choose
the shortest path but also add constraints and account for things like transfers taking more time.

2. 

As we can see in this assignment that using the shortest path with breath first search like we did in part 3 is not always the best way to do things. The shortest path with the least amount of vertices doesn't always have to be the shortest in real life, you aren't taking other factors into account other than amount of stops and its taking the first transfer it can without knowing if thats better than waiting to transfer later even if it is the same number in total vertices. Transfers take time and you have to walk and wait for the next train, busses are also a lot slower than the train and you need to wait longer for the bus to come than the train. 

3.

In our model going from North Quincy to Savin Hill would cost 1 + 7 + 1 or 9 since we have to change platforms at JFK/Umass we get a 7 for that "transfer" but in real life since the red line is split it usually wont be that big of a wait time and yes sometimes you may catch it at a bad time but I don't think a small three stop trip will cost as much as this is showing. I think something that would fix this is instead of using three separate lines for red line (Red, RedA, RedB) we can just have a Red line since we now are using a directed graph so we know the direction and can better approach the more complex parts of the map, but we still use the weight of 7 for transfers to a different color line, another way to look at it by changing the graph and not the data is just making sure that if something splits into 2 or more ways to tranfer that it shouldnt be considered 7 but something lower perhaps 3 but still not 1 since it will still require a wait sometimes. 

4.

It is reading the file first in the countVertices method that is called from the constructor so it can return V the number of vertices needed for the graph. Then the constructor calls the fillGraph method which is used so we can build the platform array within MetroGraph2 to get ID's and line names and such but also it is building the graph as well. Looking at the code of Graph from algs4 there are 3 options you have to build a graph you can either feed it: an int that will be the number of vertices, an input stream of data in a specific format, or a Graph to copy. Since our data file is not in the format that is needed for Graph to build from we would have to rewrite the data but that would also not let us use the other info about names and locations we need. We could also just try to combine the countVertices and just count while it is doing fillGraph and then use the count at the end for building the graph in fillgraph. 

5. 

In ckEdge it is checking if the x and y are both in a train line and even when it just splits so there can still be an edge between something like Red and RedA for example. This accounts for the time where there is no transfer needed but the train like just splits. Using the naming scheme of our file we see the first 3 letters are the same for the split lines, like Green and GreenC both begin with Gre but still have diffrent string names. The code uses this little trick and only compares the substring which is the first 3 letters of the string to determine if these two are in the same line. This works for now with our
specific file and what we are working with but of course will not work when a train line named something like "Y" is added. The 3 character substring is too catered to our input and not generalized for a modified/updated file or a totally diffrent file. Sometimes its a quick and easy fix with the data you are looking at for a problem but that makes the code way too spcific and not able to accept many updates or be applied to other problems. There are other, maybe more time complex ways of checking if the two are in the same train line but at least it can work in these circumstances. 


